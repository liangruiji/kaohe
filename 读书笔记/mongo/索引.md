https://mongoing.com/archives/2797

`person`集合里包含插入了4个文档，假设其存储后位置信息如下(为方便描述，文档省去_id字段)

| 位置信息 |              文档              |
| :------: | :----------------------------: |
|   pos1   | {“name” : “jack”, “age” : 19 } |
|   pos2   | {“name” : “rose”, “age” : 20 } |
|   pos3   | {“name” : “jack”, “age” : 18 } |
|   pos4   | {“name” : “tony”, “age” : 21}  |
|   pos5   | {“name” : “adam”, “age” : 18}  |

假设现在有个查询 `db.person.find( {age: 18} )`, 查询所有年龄为18岁的人，这时需要遍历所有的文档（『全表扫描』），根据位置信息读出文档，对比age字段是否为18。当然如果只有4个文档，全表扫描的开销并不大，但如果集合文档数量到百万、甚至千万上亿的时候，对集合进行全表扫描开销是非常大的，一个查询耗费数十秒甚至几分钟都有可能。

如果想加速 `db.person.find( {age: 18} ）`，就可以考虑对person表的age字段[建立索引](https://docs.mongodb.org/manual/reference/method/db.collection.createIndex/)。

```
db.person.createIndex( {age: 1} )  // 按age字段创建升序索引
```

建立索引后，MongoDB会额外存储一份按age字段升序排序的索引数据，索引结构类似如下，索引通常采用类似btree的结构持久化存储，以保证从索引里快速（`O(logN)的时间复杂度`）找出某个age值对应的位置信息，然后根据位置信息就能读取出对应的文档。

| age  | 位置信息 |
| :--: | :------: |
|  18  |   pos3   |
|  18  |   pos5   |
|  19  |   pos1   |
|  20  |   pos2   |
|  21  |   pos4   |

简单的说，索引就是将`文档`按照某个（或某些）字段顺序组织起来，以便能根据该字段高效的查询。有了索引，至少能优化如下场景的效率：

- 查询，比如查询年龄为18的所有人
- 更新/删除，将年龄为18的所有人的信息更新或删除，因为更新或删除时，需要根据条件先查询出所有符合条件的文档，所以本质上还是在优化查询
- 排序，将所有人的信息按年龄排序，如果没有索引，需要全表扫描文档，然后再对扫描的结果进行排序