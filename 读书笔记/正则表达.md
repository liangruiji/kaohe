#### 创建方式

第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

~~~js
//   /表达式/字面量创建
var re = /ABC\-001/;
//   new RegExp对象创建
var re1 = new RegExp("ABC\\-001");
~~~

#### 判断正则表达式是否匹配

使用RegExp对象上的 **test("需要匹配的字符串")** 方法判断是否匹配，返回布尔值。

~~~js
var a = "ABC-001"
re.test(a); //true
~~~



#### 规则

~~~js
\d  匹配数字
\w  匹配字母或数字
\s  匹配空格
[]  匹配范围内的字符
.   匹配除换行符以外的任意字符

*   表示任意个字符数
+   表示至少一个字符
？  表示0个或一个字符
{n} 表示n个字符
{2,10} 表示2-10个字符

A|a  匹配A或a
^    表示行的开头 如^\d  数字开头
$    表示行的结束 如\d$  数字结尾

正则匹配默认是贪婪匹配，匹配尽可能多的字符
+？  采用非贪婪匹配，匹配尽量少的字符 如 \d+?

g   表示全局搜索

i   表示忽略大小写
m   表示执行多行匹配
~~~



#### 全局搜索

g   表示全局搜索

~~~js
var r1 = /2/g;
// 等价于:
var r2 = new RegExp('2', 'g');
r1.test("2020202020");//设置全局搜索后，每次调用test或者exec，正则表达式都会更新自己的lastIndex属性，这个属性表示上次匹配到的索引，从1开始的，不是从0
console.log(r1.lastIndex);//1
r1.exec("2020202020");
console.log(r1.lastIndex);//3
~~~

全局匹配可以多次执行**exec( "")**方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：



#### 使用场景

##### 切分字符串

~~~js
//split切分字符串时  split(/表达式/);
'a b   c'.split(); // ['a b  c']
'a b   c'.split(''); // [a,'',b,'','',c]
'a b   c'.split(' ');   //[a,b,"","",c]
'a b   c'.split(/\s+/); //  [a,b,c]
'a, b , c  d'.split(/[\s\,]+/); //[a,b,c,d]
~~~

##### 分组

表达式中用 **( )** 括号表示的就是要提取的分组，定义了组，就可以在RegExp对象上用 **exec( )** 方法提取出子串来。

**exec('')** 方法匹配成功后 ，返回一个数组：

**[匹配到的整个字符串，子串1，子串2]**

匹配失败返回 **null**

~~~js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null

decodeURIComponent(JSON.parse(localStorage.getItem("__q__"))).split(/[|][/flow]/)
~~~

